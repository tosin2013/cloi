/**
 * Plugin Development Assistant for Cloi MCP Server
 * 
 * Assists with creating, installing, and managing plugins for the Cloi modular platform
 */

import fs from 'fs/promises';
import path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export class PluginDevelopmentAssistant {
  constructor(repoConfig) {
    this.repoConfig = repoConfig;
    this.projectRoot = process.env.CLOI_PROJECT_ROOT || 
                      process.env.CLOI_ROOT ||
                      path.resolve(process.cwd(), '..');
    
    this.pluginTypes = {
      analyzers: {
        description: "Language-specific error analyzers",
        baseClass: "BaseAnalyzer", 
        path: "src/plugins/analyzers",
        examples: ["javascript", "python", "rust", "go"]
      },
      providers: {
        description: "AI/LLM service providers",
        baseClass: "BaseProvider",
        path: "src/plugins/providers", 
        examples: ["claude", "openai", "gemini", "ollama"]
      },
      fixers: {
        description: "Fix application strategies",
        baseClass: "BaseFixer",
        path: "src/plugins/fixers",
        examples: ["patch", "template", "interactive"]
      },
      quality: {
        description: "Code quality and linting tools",
        baseClass: "BaseQuality",
        path: "src/plugins/quality",
        examples: ["eslint", "prettier", "sonarqube"]
      },
      integrations: {
        description: "External tool integrations",
        baseClass: "BaseIntegration", 
        path: "src/plugins/integrations",
        examples: ["github", "jira", "slack"]
      }
    };
  }

  /**
   * Generate a new plugin template based on type and specifications
   */
  async generatePluginTemplate(pluginType, pluginName, options = {}) {
    if (!this.pluginTypes[pluginType]) {
      throw new Error(`Invalid plugin type. Must be one of: ${Object.keys(this.pluginTypes).join(', ')}`);
    }

    const typeInfo = this.pluginTypes[pluginType];
    const pluginPath = path.join(this.projectRoot, typeInfo.path, pluginName);
    
    // Create plugin directory
    await fs.mkdir(pluginPath, { recursive: true });

    // Generate plugin manifest
    const manifest = this.generatePluginManifest(pluginType, pluginName, options);
    await fs.writeFile(
      path.join(pluginPath, 'plugin.json'),
      JSON.stringify(manifest, null, 2)
    );

    // Generate main plugin file
    const pluginCode = this.generatePluginCode(pluginType, pluginName, options);
    await fs.writeFile(
      path.join(pluginPath, 'index.js'),
      pluginCode
    );

    // Generate test file
    const testCode = this.generatePluginTest(pluginType, pluginName, options);
    await fs.writeFile(
      path.join(pluginPath, `${pluginName}.test.js`),
      testCode
    );

    // Generate README
    const readme = this.generatePluginReadme(pluginType, pluginName, options);
    await fs.writeFile(
      path.join(pluginPath, 'README.md'),
      readme
    );

    return {
      success: true,
      pluginPath,
      files: ['plugin.json', 'index.js', `${pluginName}.test.js`, 'README.md'],
      nextSteps: [
        `Navigate to: ${pluginPath}`,
        "Implement the required methods in index.js",
        "Add your specific logic to the plugin methods",
        "Run tests: npm run test:enhanced",
        "Load plugin: node src/cli/modular.js plugins load " + pluginType + ":" + pluginName
      ]
    };
  }

  /**
   * Generate plugin manifest (plugin.json)
   */
  generatePluginManifest(pluginType, pluginName, options) {
    return {
      name: pluginName,
      version: "1.0.0",
      type: pluginType,
      description: options.description || `A ${pluginType.slice(0, -1)} plugin for ${pluginName}`,
      author: options.author || "Generated by Cloi MCP Server",
      license: "MIT",
      keywords: [pluginType.slice(0, -1), pluginName, "cloi-plugin"],
      main: "index.js",
      cloi: {
        minVersion: "1.0.8",
        pluginVersion: "1.0"
      },
      dependencies: options.dependencies || {},
      capabilities: this.getDefaultCapabilities(pluginType),
      configuration: this.getDefaultConfiguration(pluginType, options)
    };
  }

  /**
   * Generate main plugin code
   */
  generatePluginCode(pluginType, pluginName, options) {
    const typeInfo = this.pluginTypes[pluginType];
    const className = this.toPascalCase(pluginName) + this.toPascalCase(pluginType.slice(0, -1));
    
    const templates = {
      analyzers: this.generateAnalyzerCode(className, pluginName, options),
      providers: this.generateProviderCode(className, pluginName, options),
      fixers: this.generateFixerCode(className, pluginName, options),
      quality: this.generateQualityCode(className, pluginName, options),
      integrations: this.generateIntegrationCode(className, pluginName, options)
    };

    return templates[pluginType];
  }

  /**
   * Generate analyzer plugin code
   */
  generateAnalyzerCode(className, pluginName, options) {
    return `import { BaseAnalyzer } from '../../../core/plugin-manager/interfaces.js';

/**
 * ${className} - ${options.description || `Analyzer for ${pluginName}`}
 * 
 * This analyzer handles ${pluginName}-specific errors and provides
 * intelligent analysis for debugging and fixing issues.
 */
export default class ${className} extends BaseAnalyzer {
  constructor(manifest, config) {
    super(manifest, config);
    
    // Plugin-specific initialization
    this.supportedExtensions = ${JSON.stringify(options.extensions || [`.${pluginName}`])};
    this.errorPatterns = ${JSON.stringify(options.errorPatterns || [])};
  }

  /**
   * Check if this analyzer supports the given context
   * @param {Object} context - Error context with files, error message, etc.
   * @returns {boolean} - True if this analyzer can handle the context
   */
  supports(context) {
    // Check file extensions
    if (context.files) {
      const hasSupported = context.files.some(file => 
        this.supportedExtensions.some(ext => file.endsWith(ext))
      );
      if (hasSupported) return true;
    }

    // Check error patterns
    if (context.error && this.errorPatterns.length > 0) {
      return this.errorPatterns.some(pattern => {
        const regex = new RegExp(pattern, 'i');
        return regex.test(context.error);
      });
    }

    return false;
  }

  /**
   * Analyze the error and provide insights
   * @param {string} errorOutput - The error message/output
   * @param {Object} context - Additional context
   * @returns {Object} - Analysis result
   */
  async analyze(errorOutput, context = {}) {
    try {
      const analysis = {
        language: '${pluginName}',
        analyzer: this.name,
        timestamp: new Date().toISOString(),
        errorType: this.classifyError(errorOutput),
        confidence: this.calculateConfidence(errorOutput, context),
        suggestions: await this.generateSuggestions(errorOutput, context),
        metadata: {
          files: context.files || [],
          framework: this.detectFramework(context),
          severity: this.assessSeverity(errorOutput)
        }
      };

      return analysis;
    } catch (error) {
      throw new Error(\`Analysis failed: \${error.message}\`);
    }
  }

  /**
   * Classify the type of error
   * @private
   */
  classifyError(errorOutput) {
    // TODO: Implement ${pluginName}-specific error classification
    // Examples: 'syntax', 'type', 'runtime', 'compile', 'import', 'dependency'
    
    const errorTypes = {
      syntax: /syntax\\s*error|parse\\s*error/i,
      type: /type\\s*error|undefined|not\\s*defined/i,
      runtime: /runtime\\s*error|exception/i,
      import: /import\\s*error|module.*not.*found/i
    };

    for (const [type, pattern] of Object.entries(errorTypes)) {
      if (pattern.test(errorOutput)) {
        return type;
      }
    }

    return 'unknown';
  }

  /**
   * Calculate confidence score for the analysis
   * @private 
   */
  calculateConfidence(errorOutput, context) {
    let confidence = 0.5; // Base confidence

    // Increase confidence based on file extensions
    if (context.files) {
      const supportedFiles = context.files.filter(file =>
        this.supportedExtensions.some(ext => file.endsWith(ext))
      );
      confidence += (supportedFiles.length / context.files.length) * 0.3;
    }

    // Increase confidence for known error patterns
    if (this.errorPatterns.some(pattern => new RegExp(pattern, 'i').test(errorOutput))) {
      confidence += 0.2;
    }

    return Math.min(confidence, 1.0);
  }

  /**
   * Generate suggestions for fixing the error
   * @private
   */
  async generateSuggestions(errorOutput, context) {
    // TODO: Implement ${pluginName}-specific suggestions
    return [
      "Check the error message for specific details",
      "Review the affected files for syntax issues", 
      "Consult ${pluginName} documentation for this error type"
    ];
  }

  /**
   * Detect framework being used
   * @private
   */
  detectFramework(context) {
    // TODO: Implement framework detection for ${pluginName}
    return 'unknown';
  }

  /**
   * Assess error severity
   * @private
   */
  assessSeverity(errorOutput) {
    if (/fatal|critical|severe/i.test(errorOutput)) return 'high';
    if (/warning|warn/i.test(errorOutput)) return 'low';
    return 'medium';
  }

  /**
   * Get plugin priority for this context
   */
  getPriority(context) {
    return this.supports(context) ? this.calculateConfidence('', context) * 100 : 0;
  }
}
`;
  }

  /**
   * Generate provider plugin code
   */
  generateProviderCode(className, pluginName, options) {
    return `import { BaseProvider } from '../../../core/plugin-manager/interfaces.js';

/**
 * ${className} - ${options.description || `Provider for ${pluginName} AI service`}
 */
export default class ${className} extends BaseProvider {
  constructor(manifest, config) {
    super(manifest, config);
    
    // Provider-specific configuration
    this.apiKey = this.getConfig('apiKey');
    this.baseUrl = this.getConfig('baseUrl', '${options.baseUrl || 'https://api.example.com'}');
    this.defaultModel = this.getConfig('defaultModel', '${options.defaultModel || 'default'}');
  }

  /**
   * Check if provider is available and configured
   */
  async isAvailable() {
    try {
      // TODO: Implement availability check for ${pluginName}
      return !!this.apiKey;
    } catch (error) {
      return false;
    }
  }

  /**
   * Query the ${pluginName} API
   */
  async query(prompt, options = {}) {
    if (!await this.isAvailable()) {
      throw new Error('${className} is not available or not configured');
    }

    try {
      // TODO: Implement actual ${pluginName} API integration
      const response = {
        response: \`Mock response from \${this.name} for: \${prompt.substring(0, 50)}...\`,
        model: options.model || this.defaultModel,
        usage: {
          promptTokens: Math.floor(prompt.length / 4),
          responseTokens: 100,
          totalTokens: Math.floor(prompt.length / 4) + 100
        }
      };

      return response;
    } catch (error) {
      throw new Error(\`${pluginName} query failed: \${error.message}\`);
    }
  }

  /**
   * Get supported models
   */
  getSupportedModels() {
    return ${JSON.stringify(options.models || ['default'])};
  }

  /**
   * Get provider capabilities
   */
  getCapabilities() {
    return {
      streaming: ${options.streaming || false},
      functionCalling: ${options.functionCalling || false},
      imageInput: ${options.imageInput || false},
      maxTokens: ${options.maxTokens || 4096}
    };
  }
}
`;
  }

  /**
   * Generate other plugin types (simplified)
   */
  generateFixerCode(className, pluginName, options) {
    return `import { BaseFixer } from '../../../core/plugin-manager/interfaces.js';

export default class ${className} extends BaseFixer {
  async applyFix(fix, context) {
    // TODO: Implement ${pluginName} fix application
    throw new Error('Fix application not implemented');
  }
}
`;
  }

  generateQualityCode(className, pluginName, options) {
    return `import { BaseQuality } from '../../../core/plugin-manager/interfaces.js';

export default class ${className} extends BaseQuality {
  async analyze(files, options) {
    // TODO: Implement ${pluginName} quality analysis
    throw new Error('Quality analysis not implemented');
  }
}
`;
  }

  generateIntegrationCode(className, pluginName, options) {
    return `import { BaseIntegration } from '../../../core/plugin-manager/interfaces.js';

export default class ${className} extends BaseIntegration {
  async connect() {
    // TODO: Implement ${pluginName} integration
    throw new Error('Integration not implemented');
  }
}
`;
  }

  /**
   * Generate plugin test file
   */
  generatePluginTest(pluginType, pluginName, options) {
    const className = this.toPascalCase(pluginName) + this.toPascalCase(pluginType.slice(0, -1));
    
    return `/**
 * Test suite for ${className}
 */

import { describe, it, expect, beforeEach } from './test-framework.js';
import ${className} from './index.js';

describe('${className}', () => {
  let plugin;
  const mockManifest = { name: '${pluginName}', version: '1.0.0' };
  const mockConfig = { test: true };

  beforeEach(() => {
    plugin = new ${className}(mockManifest, mockConfig);
  });

  it('should initialize correctly', () => {
    expect(plugin.name).toBe('${pluginName}');
    expect(plugin.version).toBe('1.0.0');
  });

  ${pluginType === 'analyzers' ? `
  it('should support relevant contexts', () => {
    const context = { files: ['test.${pluginName}'], error: 'Test error' };
    expect(plugin.supports(context)).toBe(true);
  });

  it('should analyze errors correctly', async () => {
    const result = await plugin.analyze('Test error', { files: ['test.${pluginName}'] });
    expect(result.language).toBe('${pluginName}');
    expect(result.analyzer).toBe('${pluginName}');
  });
  ` : ''}

  ${pluginType === 'providers' ? `
  it('should check availability', async () => {
    const available = await plugin.isAvailable();
    expect(typeof available).toBe('boolean');
  });

  it('should query successfully', async () => {
    // Mock successful query
    const result = await plugin.query('Test prompt');
    expect(result.response).toBeDefined();
  });
  ` : ''}

  // Add more tests specific to your plugin functionality
});
`;
  }

  /**
   * Generate plugin README
   */
  generatePluginReadme(pluginType, pluginName, options) {
    const className = this.toPascalCase(pluginName) + this.toPascalCase(pluginType.slice(0, -1));
    
    return `# ${className}

${options.description || `A ${pluginType.slice(0, -1)} plugin for ${pluginName} integration with Cloi.`}

## Overview

This plugin extends Cloi's modular platform to support ${pluginName}. It provides:

${pluginType === 'analyzers' ? `
- Error analysis for ${pluginName} code
- Framework detection
- Intelligent suggestions for common issues
- Integration with Cloi's debugging workflow
` : ''}

${pluginType === 'providers' ? `
- Integration with ${pluginName} AI services
- Support for multiple models
- Streaming and non-streaming responses
- Token usage tracking
` : ''}

## Installation

This plugin is installed in the Cloi plugin directory:

\`\`\`bash
# Plugin is located at: src/plugins/${pluginType}/${pluginName}/
# Load the plugin:
node src/cli/modular.js plugins load ${pluginType}:${pluginName}
\`\`\`

## Configuration

Add configuration to your Cloi config file:

\`\`\`json
{
  "plugins": {
    "${pluginType}": {
      "${pluginName}": {
        ${pluginType === 'providers' ? `
        "apiKey": "your-api-key",
        "baseUrl": "${options.baseUrl || 'https://api.example.com'}",
        "defaultModel": "${options.defaultModel || 'default'}"
        ` : `
        "enabled": true,
        "priority": 1
        `}
      }
    }
  }
}
\`\`\`

## Usage

${pluginType === 'analyzers' ? `
\`\`\`bash
# Analyze ${pluginName} errors
node src/cli/modular.js analyze "YourError: message" --files your-file.${pluginName}
\`\`\`
` : ''}

${pluginType === 'providers' ? `
\`\`\`bash
# Use ${pluginName} provider for analysis
node src/cli/modular.js config set providers.default ${pluginName}
node src/cli/modular.js analyze "Error message"
\`\`\`
` : ''}

## Development

### Testing

\`\`\`bash
# Run plugin tests
npm run test:enhanced
\`\`\`

### Contributing

1. Implement the required methods in \`index.js\`
2. Add comprehensive tests in \`${pluginName}.test.js\`
3. Update this README with usage examples
4. Test with real ${pluginName} projects

## API Reference

### ${className}

${pluginType === 'analyzers' ? `
#### \`supports(context)\`
Checks if this analyzer can handle the given error context.

#### \`analyze(errorOutput, context)\`
Analyzes the error and returns structured results.

#### \`getPriority(context)\` 
Returns priority score for analyzer selection.
` : ''}

${pluginType === 'providers' ? `
#### \`isAvailable()\`
Checks if the provider is configured and available.

#### \`query(prompt, options)\`
Sends a query to the ${pluginName} service.

#### \`getSupportedModels()\`
Returns list of supported models.

#### \`getCapabilities()\`
Returns provider capabilities.
` : ''}

## License

MIT

## Support

For issues specific to this plugin, check:
1. ${pluginName} documentation
2. Cloi plugin development guide
3. GitHub issues
`;
  }

  /**
   * Install a plugin from a local directory or git repository
   */
  async installPlugin(source, options = {}) {
    try {
      let pluginPath;
      let manifest;

      if (source.startsWith('http') || source.includes('.git')) {
        // Git repository
        const tempDir = path.join(this.projectRoot, '.temp', 'plugin-install');
        await fs.mkdir(tempDir, { recursive: true });
        
        await execAsync(`git clone ${source} ${tempDir}`);
        
        // Read manifest
        const manifestPath = path.join(tempDir, 'plugin.json');
        manifest = JSON.parse(await fs.readFile(manifestPath, 'utf-8'));
        
        // Copy to correct location
        const targetPath = path.join(this.projectRoot, this.pluginTypes[manifest.type].path, manifest.name);
        await execAsync(`cp -r ${tempDir} ${targetPath}`);
        
        // Cleanup
        await execAsync(`rm -rf ${tempDir}`);
        pluginPath = targetPath;
        
      } else {
        // Local directory
        const manifestPath = path.join(source, 'plugin.json');
        manifest = JSON.parse(await fs.readFile(manifestPath, 'utf-8'));
        
        const targetPath = path.join(this.projectRoot, this.pluginTypes[manifest.type].path, manifest.name);
        await execAsync(`cp -r ${source} ${targetPath}`);
        pluginPath = targetPath;
      }

      // Install dependencies if needed
      if (manifest.dependencies && Object.keys(manifest.dependencies).length > 0) {
        const packageJsonPath = path.join(pluginPath, 'package.json');
        const packageExists = await fs.access(packageJsonPath).then(() => true).catch(() => false);
        
        if (packageExists) {
          await execAsync('npm install', { cwd: pluginPath });
        }
      }

      return {
        success: true,
        plugin: manifest,
        location: pluginPath,
        message: `Plugin ${manifest.name} installed successfully`
      };
      
    } catch (error) {
      throw new Error(`Plugin installation failed: ${error.message}`);
    }
  }

  /**
   * List available plugin templates and examples
   */
  async listPluginTemplates() {
    const templates = {};
    
    for (const [type, info] of Object.entries(this.pluginTypes)) {
      templates[type] = {
        description: info.description,
        baseClass: info.baseClass,
        examples: info.examples,
        path: info.path
      };
    }

    return {
      availableTypes: Object.keys(this.pluginTypes),
      templates,
      examples: {
        createAnalyzer: "generate_plugin_template analyzers python --description 'Python error analyzer'",
        createProvider: "generate_plugin_template providers openai --description 'OpenAI GPT integration'",
        installFromGit: "install_plugin https://github.com/user/cloi-plugin-example.git"
      }
    };
  }

  /**
   * Validate plugin structure and manifest
   */
  async validatePlugin(pluginPath) {
    const errors = [];
    const warnings = [];
    
    try {
      // Check required files
      const requiredFiles = ['plugin.json', 'index.js'];
      for (const file of requiredFiles) {
        const filePath = path.join(pluginPath, file);
        try {
          await fs.access(filePath);
        } catch {
          errors.push(`Missing required file: ${file}`);
        }
      }

      // Validate manifest
      try {
        const manifestPath = path.join(pluginPath, 'plugin.json');
        const manifest = JSON.parse(await fs.readFile(manifestPath, 'utf-8'));
        
        const requiredFields = ['name', 'version', 'type', 'main'];
        for (const field of requiredFields) {
          if (!manifest[field]) {
            errors.push(`Missing required manifest field: ${field}`);
          }
        }

        if (manifest.type && !this.pluginTypes[manifest.type]) {
          errors.push(`Invalid plugin type: ${manifest.type}`);
        }
        
      } catch (error) {
        errors.push(`Invalid plugin.json: ${error.message}`);
      }

      // Check if plugin file is valid JavaScript
      try {
        const indexPath = path.join(pluginPath, 'index.js');
        const content = await fs.readFile(indexPath, 'utf-8');
        
        if (!content.includes('export default class')) {
          warnings.push('Plugin should export a default class');
        }
        
      } catch (error) {
        errors.push(`Cannot read index.js: ${error.message}`);
      }

      return {
        valid: errors.length === 0,
        errors,
        warnings,
        pluginPath
      };
      
    } catch (error) {
      return {
        valid: false,
        errors: [`Validation failed: ${error.message}`],
        warnings: [],
        pluginPath
      };
    }
  }

  /**
   * Helper methods
   */
  toPascalCase(str) {
    return str.replace(/(?:^|[\s-_])(\w)/g, (_, char) => char.toUpperCase());
  }

  getDefaultCapabilities(pluginType) {
    const capabilities = {
      analyzers: ["error-analysis", "framework-detection", "suggestions"],
      providers: ["query", "streaming", "models"],
      fixers: ["apply-fix", "validation", "rollback"], 
      quality: ["linting", "formatting", "metrics"],
      integrations: ["api-calls", "webhooks", "auth"]
    };
    
    return capabilities[pluginType] || [];
  }

  getDefaultConfiguration(pluginType, options) {
    const defaults = {
      analyzers: {
        priority: 1,
        enabled: true,
        timeout: 30000
      },
      providers: {
        timeout: 60000,
        retries: 3,
        maxTokens: 4096
      },
      fixers: {
        backup: true,
        dryRun: false
      },
      quality: {
        severity: "warning",
        autoFix: false
      },
      integrations: {
        rateLimit: 100,
        timeout: 30000
      }
    };

    return { ...defaults[pluginType], ...options.config };
  }
}